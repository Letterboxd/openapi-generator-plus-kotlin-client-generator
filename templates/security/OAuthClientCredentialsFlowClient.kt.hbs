/*
 * {{>frag/generatedBy}}
 */

package {{securityPackage}}

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.okhttp.OkHttp
import io.ktor.client.request.HttpRequest
import io.ktor.client.request.HttpRequestBuilder
import io.ktor.client.request.forms.submitForm
import io.ktor.http.HttpStatusCode
import io.ktor.http.parameters
import kotlinx.datetime.Clock
import java.net.URL
import kotlin.time.Duration

/** A client for the OAuth 2.0 Client Credentials Flow */
class OAuthClientCredentialsFlowClient(
    clientId: String,
    clientSecret: String,
    refreshURL: URL? = null,
    val tokenURL: URL,
    autoRefreshInterval: Duration? = null,
    accessTokenDidChange: AccessTokenHandler? = null
): AbstractOAuthFlowClient(
    clientId, clientSecret, refreshURL, autoRefreshInterval, accessTokenDidChange
) {
    /** Authenticate the security client, requesting the given [scopes] with an optional, additional [params] */
    suspend fun authenticate(scopes: List<String>?, params: Map<String, String>? = null) {
        val preEmptiveRequestInstant = Clock.System.now()

        HttpClient(OkHttp).use { client ->
            val response = client.submitForm(
                url = tokenURL.toString(),
                formParameters = parameters {
                    append("grant_type", "client_credentials")
                    append("client_id", clientId)
                    append("client_secret", clientSecret)

                    scopes?.let {
                        append("scope", it.joinToString(separator = " "))
                    }

                    params?.entries?.forEach { (key, value) ->
                        append(key, value)
                    }
                }
            )

            when (response.status) {
                HttpStatusCode.OK -> {
                    val token: OAuthAccessToken = response.body()
                    token.createdAt = preEmptiveRequestInstant
                    tokenManager.setAccessToken(token)
                }
                else -> error("authenticationFailed")
            }
        }

    }

    override suspend fun authorize(
        request: HttpRequestBuilder,
        securityScheme: SecurityScheme,
        scopes: List<String>?
    ) {
        // do nothing
    }

    override suspend fun reauthenticate(
        failedRequest: HttpRequest,
        securityScheme: SecurityScheme,
        scopes: List<String>?
    ) {
        try {
            super.reauthenticate(failedRequest, securityScheme, scopes)
        } catch (e: Exception) {
            authenticate(scopes)
        }
    }
}
