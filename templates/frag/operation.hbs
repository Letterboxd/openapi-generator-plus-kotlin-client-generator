{{#join '_params' ', '}}
{{#each parameters}}
{{{name}}}: {{{nativeType}}}{{#unless required}} = null{{/unless}}
{{/each}}
{{#if requestBody.nativeType}}
{{#with requestBody}}
requestBody: {{{nativeType}}}{{#unless required}} = null{{/unless}}
{{/with}}
{{/if}}
{{/join}}
{{#join '_callParams' ', '}}
{{#each parameters}}
{{{name}}} = {{{name}}}
{{/each}}
{{#if requestBody.nativeType}}
{{#with requestBody}}
{{{name}}} = {{{name}}}
{{/with}}
{{/if}}
{{/join}}
{{#join '_requestName' ''}}
{{{name}}}QueryParams
{{/join}}
{{#join '_requestCallParams' ', '}}
{{#each parameters}}
{{{name}}} = queryParams.{{{name}}}
{{/each}}
{{#if requestBody.nativeType}}
{{#with requestBody}}
requestBody = requestBody
{{/with}}
{{/if}}
{{/join}}
{{#join '_resultClassName' ''}}
{{className name}}Result
{{/join}}
{{#join '_fullPath' ''}}
{{{group.path}}}{{{path}}}
{{/join}}
sealed class {{{_resultClassName}}} {
{{#each responses}}
    {{!-- {{#ifneq code 401}} --}}
    {{#if description}}
    /** {{{description}}} */
    {{/if}}
    {{#if defaultContent.nativeType}}
    data class `{{{code}}}`(val value: {{{defaultContent.nativeType}}}): {{{../_resultClassName}}}()
    {{else}}
    data object `{{{code}}}`: {{{../_resultClassName}}}()
    {{/if}}
    {{!-- {{/ifneq}} --}}
{{/each}}
    /** Unexpected response from the API. */
    data class UnexpectedResponse(val response: io.ktor.client.statement.HttpResponse): {{{_resultClassName}}}()
}

{{#if (gt (count parameters) 1)}}
{{>frag/parametersStruct queryParamsClassName=(className _requestName)}}

{{>frag/operationDocumentation}}
{{#if deprecated}}
@kotlin.Deprecated(message = "This function is deprecated.")
{{/if}}
{{#if requestBody.nativeType}}
{{log .}}
{{/if}}
open suspend fun {{{name}}}(queryParams: {{{className _requestName}}}{{#if requestBody.nativeType}}, requestBody: {{{requestBody.nativeType}}}{{#unless requestBody.required}} = nil{{/unless}}{{/if}}): {{className name}}Result {
    return {{{name}}}({{{_requestCallParams}}})
}

{{/if}}
{{>frag/operationDocumentation}}
{{#if deprecated}}
@kotlin.Deprecated(message = "This function is deprecated.")
{{/if}}
open suspend fun {{{name}}}({{{_params}}}): {{className name}}Result {
    val path = "{{{stripLeadingSlash _fullPath}}}"
    {{#if pathParams}}
    {{#each pathParams}}
        .replace("{{safe '{'}}{{{serializedName}}}{{safe '}'}}", "${{identifier name}}")
    {{/each}}
    {{/if}}
    val response = client.{{{lowerCase httpMethod}}}(path){{#if _params}} {
        {{#if queryParams}}
        url {
            {{#each queryParams}}
            {{#ifeq schema.schemaType "ARRAY"}}
            {{{name}}}{{#unless required}}?{{/unless}}.forEach { parameters.append("{{{name}}}", "$it") }
            {{else}}
            {{#if required}}
            parameters.append("{{{name}}}", "${{{name}}}")
            {{else}}
            {{{name}}}?.let { parameters.append("{{{name}}}", "$it") }
            {{/if}}
            {{/ifeq}}
            {{/each}}
        }
        {{/if}}
        {{#if requestBody.nativeType}}
        {{#with requestBody}}
        contentType(ContentType.parse("{{{defaultContent.mediaType.mimeType}}}"))
        setBody(requestBody)
        {{/with}}
        {{/if}}
    }
    {{/if}}

    return when (response.status) {
    {{#each responses}}
        {{!-- {{#ifneq code 401}} --}}
        io.ktor.http.HttpStatusCode.fromValue({{{code}}}) -> {
        {{#if defaultContent.nativeType}}
            val body: {{{defaultContent.nativeType.concreteType}}} = response.body()
            {{../_resultClassName}}.`{{{code}}}`(body)
            {{!-- do {
                val decodedData = JSONDecoder().decode({{{defaultContent.nativeType.concreteType}}}.self, from: data)
                return .`{{{code}}}`(decodedData)
            } catch {
                throw APIError.invalidResponse(error, response: response, data: data)
            } --}}
        {{else}}
            {{../_resultClassName}}.`{{{code}}}`
        {{/if}}
        }
        {{!-- {{/ifneq}} --}}
    {{/each}}
    {{!-- {{#if securityRequirements}}
        HttpStatusCode.Unauthorized -> {
            if allowsReauth, val securityClient = configuration.securityClient {
                var didAuthenticate = false
                var lastError: Error?
                {{#each securityRequirements.requirements}}
                if !didAuthenticate {
                    do {
                        {{#each schemes}}
                        securityClient.reauthenticate(failedRequest: __request, securityScheme: .{{{identifier scheme.name}}}, scopes: [{{#each scopes}}{{{stringLiteral name}}}{{#unless @last}}, {{/unless}}{{/each}}])
                        {{/each}}
                        didAuthenticate = true
                    } catch (val error) {
                        lastError = error
                    }
                }
                {{/each}}
                {{#unless securityRequirements.optional}}
                if !didAuthenticate {
                    throw lastError!
                }
                {{/unless}}
                return {{{name}}}({{{_callParams}}}{{#if _callParams}}, {{/if}}allowsReauth = false)
            } else {
                throw APIError.authenticationFailed(response, data: data)
            }
        }
    {{/if}} --}}
        else -> {{_resultClassName}}.UnexpectedResponse(response)
    }
}

{{!-- {{>frag/operationDocumentation}}
open suspend fun {{{name}}}Request({{{_params}}}): URLRequest {
    val localVarPath = "{{{group.path}}}{{{path}}}"
    {{#each pathParams}}
        .replacingOccurrences(of: "{{safe '{'}}{{{serializedName}}}{{safe '}'}}", with: String({{identifier name}}).addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)
    {{/each}}

    var localVarHeaderParameter = [NameValuePair]()
    localVarHeaderParameter.removeAll()

    var localVarUrlComponents = URLComponents(string: "\(self.basePath)\(localVarPath)")!
    var localVarQueryParameter = [NameValuePair]()
    localVarUrlComponents.queryItems?.let { localVarExistingQueryItems ->
        localVarQueryParameter.append(queryItems: localVarExistingQueryItems)
    }

{{#if queryParams}}
{{#each queryParams}}
    {{>frag/requestParameter dest='localVarQueryParameter' var=(identifier name) encoding=encoding}}
{{/each}}

{{/if}}
    localVarUrlComponents.queryItems = localVarQueryParameter.count > 0 ? localVarQueryParameter.toURLQueryItems() : null

    var localVarRequest = URLRequest(url: localVarUrlComponents.url!, cachePolicy: self.cachePolicy, timeoutInterval: self.timeoutInterval)
    localVarRequest.httpMethod = {{{stringLiteral httpMethod}}}

{{#each headerParams}}
    {{>frag/requestParameter dest='localVarHeaderParameter' var=(identifier name) encoding=encoding}}

{{/each}}
{{#if cookieParams}}
    var localVarCookieParams = [NameValuePair]()
{{#each cookieParams}}
    {{>frag/requestParameter dest='localVarCookieParams' var=(identifier name) encoding=encoding}}

{{/each}}
    localVarHeaderParameter.set("Cookie", localVarCookieParams.toString(separator: "; "))

{{/if}}
{{#if requestBody.nativeType}}
{{#with requestBody}}
    {{#if required}}
    {{>frag/requestBody}}
    {{else}}
    {{{name}}}?.let { {{{name}}} ->
        {{>frag/requestBody}}
    }
    {{/if}}
{{/with}}

{{/if}}
    localVarHeaderParameter.forEach { item -> localVarRequest.addValue(item.value!, forHTTPHeaderField: item.name) }

    {{>frag/requestSecurity}}

    self.configuration.finalizeRequestBlock?.let { localVarFinalizeRequestBlock ->
        localVarFinalizeRequestBlock(&localVarRequest)
    }

    return localVarRequest
} --}}
