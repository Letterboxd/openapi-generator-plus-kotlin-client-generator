/* 
 * {{>frag/generatedBy}}
 */

package {{supportPackage}}

/** [value] will be a string in ISO 8601 date time format, e.g. 2020-08-30T18:43:00Z */
@kotlinx.serialization.Serializable(with = Instant.Serializer::class)
data class Instant(val value: String){{#if @root.isJavaSerializable}} : java.io.Serializable{{/if}} {
    val kInstant: kotlinx.datetime.Instant
        get() = kotlinx.datetime.Instant.parse(value)

    override fun toString(): String = value

    fun parse(kInstant: kotlinx.datetime.Instant) = Instant(kInstant.toString())

    object Serializer : kotlinx.serialization.KSerializer<Instant>{{#if @root.isJavaSerializable}}, java.io.Serializable{{/if}} {
        {{#if @root.isJavaSerializable}}
        private fun readResolve(): Any = Serializer

        {{/if}}
        override val descriptor: kotlinx.serialization.descriptors.SerialDescriptor
            get() = kotlinx.serialization.descriptors.PrimitiveSerialDescriptor(
                "{{supportPackage}}.Instant",
                kotlinx.serialization.descriptors.PrimitiveKind.STRING
            )

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder) =
            Instant(decoder.decodeString())

        override fun serialize(encoder: kotlinx.serialization.encoding.Encoder, value: Instant) =
            encoder.encodeString(value.value)
    }
}

/** [value] will be a string in ISO 8601 date format, e.g. 2020-08-30 */
@kotlinx.serialization.Serializable(with = LocalDate.Serializer::class)
data class LocalDate(val value: String){{#if @root.isJavaSerializable}} : java.io.Serializable{{/if}} {
    val kLocalDate: kotlinx.datetime.LocalDate
        get() = kotlinx.datetime.LocalDate.parse(value)

    override fun toString(): String = value

    fun parse(kLocalDate: kotlinx.datetime.LocalDate) = LocalDate(kLocalDate.toString())

    object Serializer : kotlinx.serialization.KSerializer<LocalDate>{{#if @root.isJavaSerializable}}, java.io.Serializable{{/if}} {
        {{#if @root.isJavaSerializable}}
        private fun readResolve(): Any = Serializer

        {{/if}}
        override val descriptor: kotlinx.serialization.descriptors.SerialDescriptor
            get() = kotlinx.serialization.descriptors.PrimitiveSerialDescriptor(
                "{{supportPackage}}.LocalDate",
                kotlinx.serialization.descriptors.PrimitiveKind.STRING
            )

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder) =
            LocalDate(decoder.decodeString())

        override fun serialize(encoder: kotlinx.serialization.encoding.Encoder, value: LocalDate) =
            encoder.encodeString(value.value)
    }
}

/** [value] will be a string in ISO 8601 time format, e.g. 18:43:00.004 */
@kotlinx.serialization.Serializable(with = LocalTime.Serializer::class)
data class LocalTime(val value: String){{#if @root.isJavaSerializable}} : java.io.Serializable{{/if}} {
    val kLocalTime: kotlinx.datetime.LocalTime
        get() = kotlinx.datetime.LocalTime.parse(value)

    override fun toString(): String = value

    fun parse(kLocalTime: kotlinx.datetime.LocalTime) = LocalTime(kLocalTime.toString())

    object Serializer : kotlinx.serialization.KSerializer<LocalTime>{{#if @root.isJavaSerializable}}, java.io.Serializable{{/if}} {
        {{#if @root.isJavaSerializable}}
        private fun readResolve(): Any = Serializer

        {{/if}}
        override val descriptor: kotlinx.serialization.descriptors.SerialDescriptor
            get() = kotlinx.serialization.descriptors.PrimitiveSerialDescriptor(
                "{{supportPackage}}.LocalTime",
                kotlinx.serialization.descriptors.PrimitiveKind.STRING
            )

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder) =
            LocalTime(decoder.decodeString())

        override fun serialize(encoder: kotlinx.serialization.encoding.Encoder, value: LocalTime) =
            encoder.encodeString(value.value)
    }
}
